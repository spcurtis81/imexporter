/**
 * iMessage Today — Daily DM Widget
 * =================================
 * Shows today's iMessage counts for you and a single contact, side-by-side:
 *   • Round avatars (you on the left, contact on the right)
 *   • Name labels and centered scores
 *   • Header row with icon + title
 *   • Footer row with last updated time
 *
 * 📦 DATA SOURCE
 *   • Generated by the macOS “imexporter” app:
 *     https://github.com/spcurtis81/imexporter
 *   • Reads from per-contact JSON rollups created by the exporter:
 *       iCloud Drive / Documents / Social / Messaging / iMessage /
 *         index.json
 *         _me/
 *           avatar.png
 *         <CONTACT_ID>/
 *           rollup.json
 *           avatar.png
 *     (Example <CONTACT_ID>: +447962786922)
 *
 * 👤 AVATARS
 *   • _me/avatar.png → your profile picture (left side)
 *   • <CONTACT_ID>/avatar.png → their profile picture (right side)
 *   • If missing, a circular initials placeholder is drawn.
 *
 * 🔧 PREREQUISITES
 *   • Scriptable (iOS)
 *   • Scriptable File Bookmark named “MessagesStats” pointing to:
 *       iCloud Drive / Documents / Social / Messaging / iMessage
 *   • At least one contact exported by the macOS imexporter app
 *
 * 📝 CONFIGURATION
 *   • Set CFG.contactId to the contact folder you want this widget to show.
 *   • Adjust CFG.people labels/colors if desired.
 *
 * 🔁 REFRESH
 *   • iOS controls widget refresh cadence (typically 15–60 minutes).
 *   • This script hints at CFG.refreshMinutes (default: 30).
 *
 * ——————————————————————————————————————————————
 * © Stephen Curtis, 2025. MIT License (see repo).
 */

// ╔══════════════════════════════════════════════════════════════════════╗
// ║  CONFIGURATION                                                       ║
// ╚══════════════════════════════════════════════════════════════════════╝
const CFG = {
  // Bookmark to “…/Documents/Social/Messaging/iMessage”
  bookmarkName: "MessagesStats",

  // The per-contact folder name (exact id you used in the exporter)
  contactId: "<<PHONE_NUMBER>>",   // e.g. "+447962786922"

  // People & labels (left = you, right = contact)
  people: [
    { key: "me",   label: "Ste",  placeholderBg: "#2ecc71" },
    { key: "them", label: "Kate", placeholderBg: "#27ae60" },
  ],

  // Look & feel (unchanged from your working version)
  gradient: { colors: ["#7ed957", "#28a745"], locations: [0, 1], angle: 135 },
  titleIcon: "calendar",
  titleText: "iMessage Today",
  textColor: Color.white(),

  // Sizes (Medium)
  avatarSize: 56,
  nameSize: 16,
  scoreSize: 48,
  titleSize: 16,
  footerSize: 11,

  // Global widget padding
  padTop: 12, padLeft: 24, padBottom: 12, padRight: 24,

  // Title row local insets (does NOT affect other rows)
  titleGap: 8,
  titleLeftInset: 25,
  titleRightInset: 12,

  // Internal spacing
  nameGap: 6,
  innerGap: 10,

  // Half width (fixed works well on Medium; set null for auto estimate)
  halfWidth: 170, // or null for auto

  // Footer centering bias (px). 0 = true center. +right, −left.
  footerBiasPx: 0,

  // Background refresh hint
  refreshMinutes: 30,
};

// ╔══════════════════════════════════════════════════════════════════════╗
/*  UTILITIES                                                            */
// ╚══════════════════════════════════════════════════════════════════════╝
function fontWith(size, weight){
  switch((weight||"").toLowerCase()){
    case "heavy": return Font.heavySystemFont(size);
    case "bold": return Font.boldSystemFont(size);
    case "semibold": return Font.semiboldSystemFont(size);
    default: return Font.systemFont(size);
  }
}

function todayKey(){
  const d = new Date();
  return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,"0")}-${String(d.getDate()).padStart(2,"0")}`;
}

function fmtDate(dt){
  if(!dt) return "";
  const y=dt.getFullYear(), m=String(dt.getMonth()+1).padStart(2,"0"), d=String(dt.getDate()).padStart(2,"0");
  const H=String(dt.getHours()).padStart(2,"0"), M=String(dt.getMinutes()).padStart(2,"0");
  return `${y}-${m}-${d} ${H}:${M}`;
}

function initialsFor(name){
  return (name||"?").split(/\s+/).map(s=>s?.[0]?.toUpperCase?.()||"").slice(0,2).join("") || "?";
}

function circleAvatar({text, diameter, bgHex, fg=Color.white()}){
  const ctx = new DrawContext();
  ctx.size = new Size(diameter, diameter);
  ctx.opaque = false; ctx.respectScreenScale = true;

  const p = new Path(); p.addEllipse(new Rect(0,0,diameter,diameter));
  ctx.setFillColor(new Color(bgHex));
  ctx.addPath(p); ctx.fillPath();

  const f = Font.semiboldSystemFont(Math.round(diameter*0.44));
  ctx.setFont(f); ctx.setTextColor(fg); ctx.setTextAlignedCenter();

  // slight optical baseline lift
  const y = Math.round(diameter/2 - f.pointSize/2 + 4);
  ctx.drawTextInRect(text, new Rect(0,y,diameter,f.pointSize+6));
  return ctx.getImage();
}

/** Estimate inner content width for dynamic half sizing (if enabled). */
function estimateInnerWidth(){
  const wPts = Device.screenSize().width / Device.screenScale();
  return Math.max(280, Math.min(wPts - (CFG.padLeft + CFG.padRight), 640));
}

// ╔══════════════════════════════════════════════════════════════════════╗
/*  DATA LOADING — new paths                                             */
// ╚══════════════════════════════════════════════════════════════════════╝
async function resolvePaths(){
  const fm = FileManager.iCloud();
  if(!fm.bookmarkExists(CFG.bookmarkName)){
    throw new Error(`Bookmark "${CFG.bookmarkName}" not found. Create it in Scriptable → Settings → File Bookmarks.`);
  }
  const root = fm.bookmarkedPath(CFG.bookmarkName); // …/Documents/Social/Messaging/iMessage
  const contactDir = fm.joinPath(root, CFG.contactId);
  const rollupPath = fm.joinPath(contactDir, "rollup.json");
  const meAvatarPath = fm.joinPath(fm.joinPath(root, "_me"), "avatar.png");
  const themAvatarPath = fm.joinPath(contactDir, "avatar.png");
  return { fm, root, contactDir, rollupPath, meAvatarPath, themAvatarPath };
}

async function loadRollup(rollupPath, fm){
  await fm.downloadFileFromiCloud(rollupPath);
  if (!fm.fileExists(rollupPath)) throw new Error("Rollup not found for this contact.");
  const raw = fm.readString(rollupPath);
  if (!raw) throw new Error("Rollup is empty.");
  const json = JSON.parse(raw);
  const mtime = fm.modificationDate(rollupPath);
  return { json, mtime };
}

async function loadAvatarByPath(path, fallbackText, bgHex, fm){
  try{
    if (fm.fileExists(path)){
      await fm.downloadFileFromiCloud(path);
      const img = fm.readImage(path);
      if (img) return img;
    }
  }catch(_) {}
  return circleAvatar({ text: initialsFor(fallbackText), diameter: CFG.avatarSize, bgHex });
}

// ╔══════════════════════════════════════════════════════════════════════╗
/*  UI HELPERS (layout unchanged)                                        */
// ╚══════════════════════════════════════════════════════════════════════╝

/**
 * One mirrored half:
 *   dir: "L" => [mini][gap][score]
 *        "R" => [score][gap][mini]
 */
function addHalf(container, {name, avatarImg, score, dir="L"}, halfWidth){
  const half = container.addStack();
  half.layoutHorizontally();
  half.centerAlignContent();
  half.size = new Size(halfWidth, 0);

  const makeMini = () => {
    const mini = half.addStack();
    mini.layoutVertically(); mini.centerAlignContent();
    mini.size = new Size(CFG.avatarSize, 0);

    const av = mini.addImage(avatarImg);
    av.imageSize = new Size(CFG.avatarSize, CFG.avatarSize);
    av.cornerRadius = CFG.avatarSize/2; // round mask

    mini.addSpacer(CFG.nameGap);

    const nm = mini.addText(name);
    nm.font = fontWith(CFG.nameSize, "semibold");
    nm.textColor = CFG.textColor;
    nm.textOpacity = 0.95;
    nm.centerAlignText();
    nm.size = new Size(CFG.avatarSize, 0);
  };

  const makeScore = () => {
    const col = half.addStack(); col.layoutVertically(); col.centerAlignContent();
    const sc = col.addText(String(score));
    sc.font = fontWith(CFG.scoreSize, "heavy");
    sc.textColor = CFG.textColor;
    sc.lineLimit = 1; sc.minimumScaleFactor = 0.6;
  };

  if (dir === "L") { makeMini(); half.addSpacer(CFG.innerGap); makeScore(); }
  else            { makeScore(); half.addSpacer(CFG.innerGap); makeMini(); }
}

/** Title row with local insets (does not affect other rows). */
function addTitleRow(widget){
  const row = widget.addStack(); row.layoutHorizontally();

  const content = row.addStack(); // isolated inset for title only
  content.layoutHorizontally(); content.centerAlignContent();
  content.setPadding(0, CFG.titleLeftInset, 0, CFG.titleRightInset);

  const iconImg = SFSymbol.named(CFG.titleIcon).image;
  const icon = content.addImage(iconImg);
  icon.imageSize = new Size(16,16); icon.tintColor = CFG.textColor;

  content.addSpacer(8);
  const label = content.addText(CFG.titleText);
  label.font = fontWith(CFG.titleSize, "semibold");
  label.textColor = CFG.textColor;
  label.textOpacity = 0.96;

  row.addSpacer(); // fill remainder so later rows are unaffected
}

/** Middle row: mirrored halves with flexible outer spacers. */
function addScoresRow(widget, left, right, scoreLeft, scoreRight, halfWidth){
  const mid = widget.addStack();
  mid.layoutHorizontally(); mid.centerAlignContent();

  mid.addSpacer(); // left flex
  addHalf(mid, { name:left.name,  avatarImg:left.avatar,  score:scoreLeft,  dir:"L" }, halfWidth);
  mid.addSpacer(); // middle flex
  addHalf(mid, { name:right.name, avatarImg:right.avatar, score:scoreRight, dir:"R" }, halfWidth);
  mid.addSpacer(); // right flex
}

/** Bottom row: centered footer with optional bias. */
function addFooterRow(widget, updatedText){
  const row = widget.addStack(); row.layoutHorizontally();

  if (CFG.footerBiasPx >= 0) {
    row.addSpacer(); // flexible left
    if (CFG.footerBiasPx) row.addSpacer(CFG.footerBiasPx);
  } else {
    row.addSpacer(Math.abs(CFG.footerBiasPx));
    row.addSpacer();
  }

  const foot = row.addText(`Updated: ${updatedText || ""}`);
  foot.font = Font.italicSystemFont(CFG.footerSize);
  foot.textColor = new Color("#ffffff", 0.88);
  foot.centerAlignText();

  row.addSpacer(); // flexible right
}

// ╔══════════════════════════════════════════════════════════════════════╗
/*  WIDGET CONSTRUCTION                                                  */
// ╚══════════════════════════════════════════════════════════════════════╝
function buildWidget({ left, right, scoreLeft, scoreRight, updatedText }){
  const w = new ListWidget();
  w.setPadding(CFG.padTop, CFG.padLeft, CFG.padBottom, CFG.padRight);

  // Background gradient
  const grad = new LinearGradient();
  grad.colors = CFG.gradient.colors.map(hex => new Color(hex));
  grad.locations = CFG.gradient.locations;
  grad.angle = CFG.gradient.angle;
  w.backgroundGradient = grad;

  // Compute half width (fixed or auto estimate)
  const halfWidth = (CFG.halfWidth ?? Math.floor(estimateInnerWidth()/2.6));

  // Row 1: Title
  addTitleRow(w);
  w.addSpacer(CFG.titleGap);

  // Row 2: Scores
  addScoresRow(w, left, right, scoreLeft, scoreRight, halfWidth);

  // Row 3: Footer (pinned low)
  w.addSpacer();
  addFooterRow(w, updatedText);

  w.refreshAfterDate = new Date(Date.now() + CFG.refreshMinutes*60*1000);
  return w;
}

// ╔══════════════════════════════════════════════════════════════════════╗
/*  MAIN                                                                 */
// ╚══════════════════════════════════════════════════════════════════════╝
async function run(){
  try{
    const { fm, rollupPath, meAvatarPath, themAvatarPath } = await resolvePaths();
    const { json, mtime } = await loadRollup(rollupPath, fm);

    const k = todayKey();
    const today = (json && json.days && json.days[k]) || { me:0, them:0 };

    const leftScore  = Number.isFinite(today.me)   ? today.me   : 0; // you
    const rightScore = Number.isFinite(today.them) ? today.them : 0; // them

    const updated = (json && json.updated_at)
      ? json.updated_at.replace("T"," ").slice(0,16)
      : fmtDate(mtime);

    // Load avatars from new structure (or draw placeholders)
    const leftAvatar  = await loadAvatarByPath(meAvatarPath,  CFG.people[0].label, CFG.people[0].placeholderBg,  fm);
    const rightAvatar = await loadAvatarByPath(themAvatarPath, CFG.people[1].label, CFG.people[1].placeholderBg, fm);

    const widget = buildWidget({
      left:  { name: CFG.people[0].label, avatar: leftAvatar },
      right: { name: CFG.people[1].label, avatar: rightAvatar },
      scoreLeft: leftScore,
      scoreRight: rightScore,
      updatedText: updated
    });

    Script.setWidget(widget);
    if (config.runsInApp) await widget.presentMedium();
  } catch (err){
    // Friendly error card
    const w = new ListWidget(); w.backgroundColor = new Color("#222");
    const t = w.addText("iMessage Today"); t.font = Font.semiboldSystemFont(14); t.textColor = Color.white();
    w.addSpacer(6);
    const e = w.addText(String(err)); e.font = Font.systemFont(12); e.textColor = Color.red(); e.minimumScaleFactor = 0.5;
    Script.setWidget(w);
    if (config.runsInApp) await w.presentMedium();
  }
  Script.complete();
}
await run();
