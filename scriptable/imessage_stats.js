/**
 * iMessage Stats (Medium) — Lifetime Totals, Daily Avg, Record Day
 * ================================================================
 * What it shows
 *  • Left column: "Daily Avg" and all-time "Record" (with record date)
 *  • Right column: lifetime totals for Ste, Kate, and Total
 *
 * Data source
 *  • Generated by the macOS exporter: https://github.com/spcurtis81/imexporter
 *  • File layout (per-contact):
 *      iCloud Drive / Documents / Social / Messaging / iMessage /
 *        index.json
 *        _me/
 *          avatar.png
 *        <CONTACT_ID>/
 *          rollup.json   ← this widget reads this file
 *          avatar.png    (not used in this widget, but available)
 *
 * Prerequisites
 *  • Scriptable (iOS)
 *  • Scriptable File Bookmark named "MessagesStats" that points to:
 *      iCloud Drive / Documents / Social / Messaging / iMessage
 *  • Set CFG.contactId to match the exported folder name (e.g. "+447962786922")
 *
 * Notes
 *  • No layout or style changes vs your previous working version.
 *  • Only the data-loading path has been updated to the new structure.
 *  • iOS controls widget refresh cadence; this script hints via refreshAfterDate.
 *
 * © Stephen Curtis, 2025 — MIT (see repo)
 */

// ╔══════════════════════════════════════════════════════════════════════╗
// ║  CONFIGURATION                                                       ║
// ╚══════════════════════════════════════════════════════════════════════╝
const CFG = {
  // ── New data location (per-contact folder) ───────────────────────────
  bookmarkName: "MessagesStats",          // File Bookmark → .../Documents/Social/Messaging/iMessage
  contactId: "<<PHONE_NUMBER>>",          // e.g. "+447962786922" (folder name under the bookmark)

  // Keys inside each "days[date]" object in rollup.json
  meKey: "me",
  themKey: "them",

  // Visual theme (unchanged)
  title: "iMessage Stats",
  bgGradient: { colors: ["#6F76E4", "#3E3A9E"], locations: [0, 1], angle: 135 },

  titleColor: new Color("#FFFFFF", 0.96),
  textColor:  new Color("#FFFFFF", 0.92),
  subColor:   new Color("#FFFFFF", 0.80),
  divider:    new Color("#FFFFFF", 0.28),

  // Outer padding around the whole widget content (top, left, bottom, right)
  padTop: 14, padLeft: 18, padRight: 18, padBottom: 12,

  // Title font size
  titleSize: 16,

  // Left column (Daily Avg + Record) font sizes
  leftHeaderSize: 12,   // "Daily Avg"
  leftBigSize: 38,      // big daily average number
  recordHeaderSize: 11, // "Record"
  recordValueSize: 22,  // record count number

  // Right column (All Time table) font sizes
  rightHeaderSize: 12,  // "All Time"
  rightLabelSize: 14,   // "Ste", "Kate", "Total"
  rightValueSize: 20,   // numbers

  // Vertical spacing between table rows on the right
  rowGap: 6,

  // Column layout (widths) — does NOT affect widget height
  // columnMode: "percent" → left column takes leftPercent of inner width
  //             "fixed"   → left column has fixed pixel width (leftFixedWidthPx)
  columnMode: "percent",
  leftPercent: 0.50,         // proportion for left column when using "percent"
  leftFixedWidthPx: null,    // exact px for left column when using "fixed"
  gutterPx: 10,              // space between columns

  // Footer (shows bottom-right within the right column)
  showUpdated: true,
  updatedPrefix: "Updated:",
  footerSize: 11,

  // Background refresh hint for iOS (best-effort)
  refreshMinutes: 30,
};

// ╔══════════════════════════════════════════════════════════════════════╗
/*  UTILITY HELPERS                                                      */
// ╚══════════════════════════════════════════════════════════════════════╝
function fontWith(size, weight){
  switch((weight||"").toLowerCase()){
    case "heavy":     return Font.heavySystemFont(size);
    case "bold":      return Font.boldSystemFont(size);
    case "semibold":  return Font.semiboldSystemFont(size);
    default:          return Font.systemFont(size);
  }
}
function fmtInt(n){ return Number(n||0).toLocaleString(); }

/**
 * Resolve rollup.json path for the configured contactId via bookmark.
 */
async function resolveRollupPath(){
  const fm = FileManager.iCloud();
  if (!fm.bookmarkExists(CFG.bookmarkName)){
    throw new Error(`Bookmark "${CFG.bookmarkName}" not found. (Scriptable → Settings → File Bookmarks)`);
  }
  const root = fm.bookmarkedPath(CFG.bookmarkName); // …/Documents/Social/Messaging/iMessage
  const contactDir = fm.joinPath(root, CFG.contactId);
  const rollup = fm.joinPath(contactDir, "rollup.json");
  return { fm, rollup };
}

/**
 * Load and parse rollup.json (downloads from iCloud if needed).
 */
async function loadRollup(rollupPath, fm){
  await fm.downloadFileFromiCloud(rollupPath);
  if (!fm.fileExists(rollupPath)) throw new Error(`Rollup not found at: ${rollupPath}`);
  const raw = fm.readString(rollupPath);
  if (!raw) throw new Error("Rollup file is empty.");
  return { json: JSON.parse(raw), mtime: fm.modificationDate(rollupPath) };
}

/**
 * Compute lifetime statistics from the rollup:
 * - daily average across all days
 * - record daily total and its date
 * - lifetime sums for me, them, and total
 */
function computeStats(json, meKey, themKey){
  const days = (json && json.days) || {};
  const entries = Object.entries(days);
  if (entries.length === 0) {
    return { dailyAvg:0, recordCount:0, recordDate:"—", sumMe:0, sumThem:0, sumTotal:0, updatedAt:"—" };
  }

  let sumMe = 0, sumThem = 0, sumTotal = 0;
  let recordCount = -1, recordDate = "";
  for (const [date, v] of entries){
    const m = Number(v[meKey]  ?? 0);
    const t = Number(v[themKey]?? 0);
    const tot = m + t;
    sumMe += m; sumThem += t; sumTotal += tot;
    if (tot > recordCount){ recordCount = tot; recordDate = date; }
  }

  const dailyAvg = Math.round(sumTotal / entries.length);
  return {
    dailyAvg,
    recordCount,
    recordDate,
    sumMe,
    sumThem,
    sumTotal,
    updatedAt: (json && json.updated_at)
      ? json.updated_at.replace("T"," ").slice(0,16)
      : "—",
  };
}

/** Draw a 1-px hairline divider image. */
function drawDividerImage(size, color){
  const ctx = new DrawContext();
  ctx.size = size; ctx.opaque = false; ctx.respectScreenScale = true;
  ctx.setFillColor(color);
  ctx.fillRect(new Rect(0,0,size.width,size.height));
  return ctx.getImage();
}

/** Estimate inner width (points) from device minus outer padding. */
function estimateWidgetInnerWidth(){
  const screenPts = Device.screenSize().width / Device.screenScale();
  return Math.max(280, Math.min(screenPts - (CFG.padLeft + CFG.padRight), 640));
}

/** Decide left/right column widths from CFG without impacting height. */
function computeColumnWidths() {
  const totalW = estimateWidgetInnerWidth();
  const gutter = Math.max(0, CFG.gutterPx);

  let leftW;
  if (CFG.columnMode === "fixed" && CFG.leftFixedWidthPx != null) {
    leftW = Math.min(Math.max(120, CFG.leftFixedWidthPx), totalW - gutter - 120);
  } else {
    const pct = Math.min(0.9, Math.max(0.1, CFG.leftPercent || 0.5));
    leftW = Math.floor((totalW - gutter) * pct);
  }
  const rightW = Math.max(120, totalW - gutter - leftW);
  return { leftW, rightW, gutter };
}

// ╔══════════════════════════════════════════════════════════════════════╗
/*  WIDGET LAYOUT (unchanged visuals)                                    */
// ╚══════════════════════════════════════════════════════════════════════╝
function buildWidget(stats){
  const w = new ListWidget();
  w.setPadding(CFG.padTop, CFG.padLeft, CFG.padBottom, CFG.padRight);

  // Background
  const grad = new LinearGradient();
  grad.colors = CFG.bgGradient.colors.map(c => new Color(c));
  grad.locations = CFG.bgGradient.locations;
  grad.angle = CFG.bgGradient.angle;
  w.backgroundGradient = grad;

  // ── Title ────────────────────────────────────────────────────────────
  const titleRow = w.addStack(); titleRow.layoutHorizontally();
  const icon = titleRow.addImage(SFSymbol.named("tablecells").image);
  icon.imageSize = new Size(16,16); icon.tintColor = CFG.titleColor;
  titleRow.addSpacer(8);
  const ttl = titleRow.addText(CFG.title);
  ttl.font = fontWith(CFG.titleSize, "semibold");
  ttl.textColor = CFG.titleColor;

  w.addSpacer(6);

  // ── Columns (left: daily avg + record, right: totals) ────────────────
  const { leftW, rightW, gutter } = computeColumnWidths();
  const cols = w.addStack(); cols.layoutHorizontally();

  // LEFT COLUMN
  const left = cols.addStack(); left.layoutVertically(); left.size = new Size(leftW, 0);

  const leftHdr = left.addText("Daily Avg");
  leftHdr.font = fontWith(CFG.leftHeaderSize, "semibold");
  leftHdr.textColor = CFG.subColor;
  left.addSpacer(2);

  const avgTxt = left.addText(fmtInt(stats.dailyAvg));
  avgTxt.font = fontWith(CFG.leftBigSize, "heavy");
  avgTxt.textColor = CFG.textColor;
  avgTxt.lineLimit = 1; avgTxt.minimumScaleFactor = 0.8;

  left.addSpacer(6);

  const recHdr = left.addText("Record");
  recHdr.font = fontWith(CFG.recordHeaderSize, "semibold");
  recHdr.textColor = CFG.subColor;
  left.addSpacer(1);

  const recVal = left.addText(fmtInt(stats.recordCount));
  recVal.font = fontWith(CFG.recordValueSize, "bold");
  recVal.textColor = CFG.textColor;
  recVal.lineLimit = 1; recVal.minimumScaleFactor = 0.8;

  const recDate = left.addText(`(${stats.recordDate})`);
  recDate.font = Font.italicSystemFont(CFG.footerSize);
  recDate.textColor = CFG.subColor;
  recDate.lineLimit = 1; recDate.minimumScaleFactor = 0.8;

  // GUTTER (space between columns)
  cols.addSpacer(gutter);

  // RIGHT COLUMN
  const right = cols.addStack(); right.layoutVertically(); right.size = new Size(rightW, 0);

  const rightHdr = right.addText("All Time");
  rightHdr.font = fontWith(CFG.rightHeaderSize, "semibold");
  rightHdr.textColor = CFG.subColor;
  right.addSpacer(4);

  function row(label, value, bold=false){
    const r = right.addStack(); r.layoutHorizontally();

    const l = r.addText(label);
    l.font = bold ? fontWith(CFG.rightLabelSize, "semibold")
                  : Font.systemFont(CFG.rightLabelSize);
    l.textColor = CFG.textColor;
    l.lineLimit = 1; l.minimumScaleFactor = 0.7;

    r.addSpacer();

    const v = r.addText(fmtInt(value));
    v.font = fontWith(CFG.rightValueSize, bold ? "bold" : "semibold");
    v.textColor = CFG.textColor;
    v.rightAlignText(); v.lineLimit = 1; v.minimumScaleFactor = 0.7;

    right.addSpacer(CFG.rowGap);
  }

  row("Ste",  stats.sumMe,  false);
  row("Kate", stats.sumThem, false);

  const div = right.addStack(); div.layoutHorizontally();
  const hair = div.addImage(drawDividerImage(new Size(rightW, 1), CFG.divider));
  hair.resizable = true; hair.centerAlignImage();
  right.addSpacer(CFG.rowGap);

  row("Total", stats.sumTotal, true);

  // Fill remaining vertical space, then bottom-right footer
  right.addSpacer();

  if (CFG.showUpdated){
    const footRow = right.addStack(); footRow.layoutHorizontally();
    footRow.addSpacer(); // push to right edge
    const foot = footRow.addText(`${CFG.updatedPrefix} ${stats.updatedAt}`);
    foot.font = Font.italicSystemFont(CFG.footerSize);
    foot.textColor = CFG.subColor;
    foot.lineLimit = 1; foot.minimumScaleFactor = 0.75;
  }

  // Hint to iOS when to refresh next (best-effort)
  w.refreshAfterDate = new Date(Date.now() + CFG.refreshMinutes*60*1000);
  return w;
}

// ╔══════════════════════════════════════════════════════════════════════╗
/*  MAIN                                                                 */
// ╚══════════════════════════════════════════════════════════════════════╝
async function run(){
  try{
    const { fm, rollup } = await resolveRollupPath();
    const { json } = await loadRollup(rollup, fm);

    const stats = computeStats(json, CFG.meKey, CFG.themKey);
    const w = buildWidget(stats);
    Script.setWidget(w);
    if (config.runsInApp) await w.presentMedium();
  } catch (err){
    // Friendly error card
    const w = new ListWidget(); w.backgroundColor = new Color("#222");
    const t = w.addText(CFG.title || "iMessage Stats");
    t.textColor = Color.white(); t.font = Font.semiboldSystemFont(14);
    w.addSpacer(6);
    const e = w.addText(String(err));
    e.textColor = Color.red(); e.minimumScaleFactor = 0.5;
    Script.setWidget(w);
    if (config.runsInApp) await w.presentMedium();
  }
  Script.complete();
}
await run();
