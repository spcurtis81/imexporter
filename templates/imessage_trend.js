/**
 * iMessage Trend â€” Daily History (Stacked Area, Unsmoothed)
 * =========================================================
 * Renders the last N days of your iMessage DM activity with a stacked area:
 *   â€¢ Lower area/line = You (Ste)
 *   â€¢ Upper area/line = Total (Ste + Kate)
 *   â€¢ Simple grid, legend, Monday tick labels, and â€œUpdated:â€ footer
 *
 * ğŸ“¦ DATA SOURCE
 *   â€¢ Generated by the macOS â€œimexporterâ€ app
 *   â€¢ Reads:
 *       iCloud Drive / Documents / Social / Messaging / iMessage /
 *         index.json
 *         _me/avatar.png
 *         <CONTACT_ID>/rollup.json
 *         <CONTACT_ID>/avatar.png
 *
 * ğŸ”§ Scriptable File Bookmark
 *   â€¢ Bookmark named â€œMessagesStatsâ€ pointing to the folder containing index.json
 *
 * â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
 * Â© Stephen Curtis, 2025. MIT License (see repo).
 */

// â”€â”€ CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const CFG = {
  bookmarkName: "MessagesStats",

  // If blank/placeholder, script auto-selects first enabled contact from index.json
  contactId: "",   // e.g. "+447962786922"

  meKey: "me",
  themKey: "them",

  lookbackDays: 30,
  headroom: 0.10,

  bgGradient: { colors: ["#2f8f7f", "#0f6a5d"], locations: [0, 1], angle: 135 },
  meFill:   new Color("#ffffff", 0.25),
  themFill: new Color("#ffffff", 0.40),
  meLine:   new Color("#ffffff", 0.95),
  totLine:  new Color("#ffffff", 1.00),
  grid:     new Color("#ffffff", 0.18),
  label:    new Color("#ffffff", 0.92),
  titleCol: new Color("#ffffff", 0.96),

  title: "Message History",
  updatedPrefix: "Updated:",

  padTop: 12, padLeft: 16, padRight: 16, padBottom: 12,
  titleSize: 14,
  tickSize: 10,
  footerSize: 10,

  legendFontSize: 10,
  legendBox: 10,
  legendGap: 6,
  legendItemGap: 12,

  chartHeight: 120,
  chartTopExtra: 6,
  chartBottomExtra: 8,
  yTicks: 3,

  meLineWidth: 2.0,
  totLineWidth: 2.0,

  supersample: 2,

  refreshMinutes: 30,
};


// â”€â”€ util helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function fontWith(size, weight){
  switch((weight||"").toLowerCase()){
    case "heavy": return Font.heavySystemFont(size);
    case "bold": return Font.boldSystemFont(size);
    case "semibold": return Font.semiboldSystemFont(size);
    default: return Font.systemFont(size);
  }
}
function keyFor(d){ return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,"0")}-${String(d.getDate()).padStart(2,"0")}`; }
function addDays(date, n){ const d=new Date(date); d.setDate(d.getDate()+n); return d; }
function fmtDateTime(dt){
  const y=dt.getFullYear(), m=String(dt.getMonth()+1).padStart(2,"0"), d=String(dt.getDate()).padStart(2,"0");
  const H=String(dt.getHours()).padStart(2,"0"), M=String(dt.getMinutes()).padStart(2,"0");
  return `${y}-${m}-${d} ${H}:${M}`;
}
function ddMM(d){ const dd=String(d.getDate()).padStart(2,"0"); const mm=String(d.getMonth()+1).padStart(2,"0"); return `${dd}/${mm}`; }

function isPlaceholderContactId(id){
  if(!id) return true;
  const s = String(id).trim();
  return s === "" || s.includes("PHONE_NUMBER") || s.includes("<<") || s.includes(">>");
}


// â”€â”€ iCloud root + index + contact resolution â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function resolveRootAndIndex(){
  const fm = FileManager.iCloud();
  if (!fm.bookmarkExists(CFG.bookmarkName)){
    throw new Error(`Bookmark "${CFG.bookmarkName}" not found. (Scriptable â†’ Settings â†’ File Bookmarks)`);
  }
  const root = fm.bookmarkedPath(CFG.bookmarkName);
  const indexPath = fm.joinPath(root, "index.json");

  if(!fm.fileExists(indexPath)){
    throw new Error(`index.json not found in bookmarked folder.\nBookmark points to:\n${root}`);
  }

  await fm.downloadFileFromiCloud(indexPath);
  const raw = fm.readString(indexPath);
  let index;
  try { index = JSON.parse(raw); }
  catch { throw new Error("index.json exists but is not valid JSON."); }

  return { fm, root, indexPath, index };
}

function pickContactIdFromIndex(index){
  const contacts = Array.isArray(index?.contacts) ? index.contacts : [];
  const enabled = contacts.filter(c => c && (c.enabled === undefined || c.enabled === true));

  const c1 = enabled.find(c => c.number);
  if (c1?.number) return c1.number;

  const c2 = enabled.find(c => c.id);
  if (c2?.id) return c2.id;

  return null;
}

function listLikelyContactFolders(fm, root){
  try {
    const items = fm.listContents(root) || [];
    return items.filter(n => n && n.startsWith("+")).slice(0, 20);
  } catch {
    return [];
  }
}

async function buildPathsForContact({ fm, root, contactId }){
  const contactDir = fm.joinPath(root, contactId);
  const rollupPath = fm.joinPath(contactDir, "rollup.json");
  const meAvatarPath = fm.joinPath(fm.joinPath(root, "_me"), "avatar.png");
  const themAvatarPath = fm.joinPath(contactDir, "avatar.png");
  return { contactDir, rollupPath, meAvatarPath, themAvatarPath };
}

async function safeDownload(fm, path){
  if(!fm.fileExists(path)) return false;
  await fm.downloadFileFromiCloud(path);
  return true;
}

async function prefetchIcloudFiles({ fm, indexPath, rollupPath, meAvatarPath, themAvatarPath }){
  await safeDownload(fm, indexPath);
  await safeDownload(fm, rollupPath);
  await safeDownload(fm, meAvatarPath);
  await safeDownload(fm, themAvatarPath);
}

async function loadRollup(rollupPath, fm, contactId, root){
  if (!fm.fileExists(rollupPath)){
    const options = listLikelyContactFolders(fm, root);
    const hint = options.length ? `\n\nContact folders I can see:\n- ${options.join("\n- ")}` : "";
    throw new Error(
      `rollup.json not found for contact "${contactId}".\nExpected:\n${rollupPath}\n\nCheck CFG.contactId or ensure exporter has created rollup.json.${hint}`
    );
  }
  await fm.downloadFileFromiCloud(rollupPath);
  const raw = fm.readString(rollupPath);
  if (!raw) throw new Error("rollup.json is empty.");
  return { json: JSON.parse(raw), mtime: fm.modificationDate(rollupPath) };
}


// â”€â”€ data prep (UNCHANGED) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildSeries(data, days, meKey, themKey){
  const map = (data && data.days) || {};
  const end = new Date();
  const start = addDays(end, -(days-1));
  const dates=[], me=[], them=[], total=[];
  for (let i=0;i<days;i++){
    const d = addDays(start, i);
    const rec = map[keyFor(d)] || {};
    const m = Number.isFinite(rec[meKey]) ? rec[meKey] : 0;
    const t = Number.isFinite(rec[themKey]) ? rec[themKey] : 0;
    dates.push(d); me.push(m); them.push(t); total.push(m+t);
  }
  return { dates, me, them, total, start, end };
}
function yMaxFor(total, headroom){ const mx = Math.max(1, ...total); return mx * (1 + headroom); }


// â”€â”€ chart: straight lines + stacked fills (UNCHANGED) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawStackedLines(size, meArr, themArr, yMax){
  const SS = Math.max(1, CFG.supersample|0);
  const Hi = new Size(size.width*SS, size.height*SS);

  const ctx = new DrawContext();
  ctx.size = Hi; ctx.opaque = false; ctx.respectScreenScale = true;

  const W = Hi.width, H = Hi.height;
  const n = meArr.length;
  const stepX = n>1 ? (W-1)/(n-1) : 0;
  const pxPerY = H / yMax;

  const ptsMe = [], ptsTot = [];
  for (let i=0;i<n;i++){
    const x = i*stepX;
    const yMe  = H - (meArr[i]              * pxPerY);
    const yTot = H - ((meArr[i]+themArr[i]) * pxPerY);
    ptsMe.push({x, y: Math.max(0, Math.min(H, yMe ))});
    ptsTot.push({x, y: Math.max(0, Math.min(H, yTot))});
  }

  // grid
  ctx.setStrokeColor(CFG.grid); ctx.setLineWidth(SS*1);
  for (let g=0; g<CFG.yTicks; g++){
    const frac = g/(CFG.yTicks-1), y = H - frac*H;
    const p = new Path(); p.move(new Point(0,y)); p.addLine(new Point(W,y));
    ctx.addPath(p); ctx.strokePath();
  }

  // area: me
  {
    const p = new Path();
    p.move(new Point(ptsMe[0].x, H));
    for (let i=0;i<ptsMe.length;i++) p.addLine(new Point(ptsMe[i].x, ptsMe[i].y));
    p.addLine(new Point(ptsMe[ptsMe.length-1].x, H));
    p.closeSubpath();
    ctx.setFillColor(CFG.meFill); ctx.addPath(p); ctx.fillPath();

    const pl = new Path();
    pl.move(new Point(ptsMe[0].x, ptsMe[0].y));
    for (let i=1;i<ptsMe.length;i++) pl.addLine(new Point(ptsMe[i].x, ptsMe[i].y));
    ctx.setStrokeColor(CFG.meLine); ctx.setLineWidth(CFG.meLineWidth*SS);
    ctx.addPath(pl); ctx.strokePath();
  }

  // area: them (between me and total)
  {
    const p = new Path();
    p.move(new Point(ptsTot[0].x, ptsTot[0].y));
    for (let i=1;i<ptsTot.length;i++) p.addLine(new Point(ptsTot[i].x, ptsTot[i].y));
    for (let i=ptsMe.length-1;i>=0;i--) p.addLine(new Point(ptsMe[i].x, ptsMe[i].y));
    p.closeSubpath();
    ctx.setFillColor(CFG.themFill); ctx.addPath(p); ctx.fillPath();

    const pl = new Path();
    pl.move(new Point(ptsTot[0].x, ptsTot[0].y));
    for (let i=1;i<ptsTot.length;i++) pl.addLine(new Point(ptsTot[i].x, ptsTot[i].y));
    ctx.setStrokeColor(CFG.totLine); ctx.setLineWidth(CFG.totLineWidth*SS);
    ctx.addPath(pl); ctx.strokePath();
  }

  // downscale
  const hi = ctx.getImage();
  const ctx2 = new DrawContext();
  ctx2.size = size; ctx2.opaque = false; ctx2.respectScreenScale = true;
  ctx2.drawImageInRect(hi, new Rect(0,0,size.width,size.height));
  return ctx2.getImage();
}

function swatchImage(color, size){
  const ctx = new DrawContext();
  ctx.size = new Size(size, size);
  ctx.opaque = false; ctx.respectScreenScale = true;
  ctx.setFillColor(color);
  ctx.fillRect(new Rect(0,0,size,size));
  ctx.setStrokeColor(new Color("#ffffff", 0.8));
  ctx.setLineWidth(1);
  ctx.strokeRect(new Rect(0.5,0.5,size-1,size-1));
  return ctx.getImage();
}


// â”€â”€ widget assembly (UNCHANGED except contact labels remain literal) â”€â”€â”€â”€
function buildWidget({series, updatedAt, yMax}){
  const w = new ListWidget();
  w.setPadding(CFG.padTop, CFG.padLeft, CFG.padBottom, CFG.padRight);

  const grad = new LinearGradient();
  grad.colors = CFG.bgGradient.colors.map(c => new Color(c));
  grad.locations = CFG.bgGradient.locations;
  grad.angle = CFG.bgGradient.angle;
  w.backgroundGradient = grad;

  // Title + legend row
  const trow = w.addStack(); trow.layoutHorizontally();
  const icon = trow.addImage(SFSymbol.named("chart.xyaxis.line").image);
  icon.imageSize = new Size(16,16); icon.tintColor = CFG.titleCol;
  trow.addSpacer(8);
  const tt = trow.addText(CFG.title);
  tt.font = fontWith(CFG.titleSize, "semibold");
  tt.textColor = CFG.titleCol;

  trow.addSpacer();

  const legend = trow.addStack();
  legend.layoutHorizontally(); legend.centerAlignContent();

  const imgMe = legend.addImage(swatchImage(CFG.meFill, CFG.legendBox));
  imgMe.imageSize = new Size(CFG.legendBox, CFG.legendBox);
  imgMe.cornerRadius = 2;
  legend.addSpacer(CFG.legendGap);
  const lMe = legend.addText("Ste");
  lMe.font = Font.systemFont(CFG.legendFontSize);
  lMe.textColor = CFG.label;

  legend.addSpacer(CFG.legendItemGap);

  const imgTh = legend.addImage(swatchImage(CFG.themFill, CFG.legendBox));
  imgTh.imageSize = new Size(CFG.legendBox, CFG.legendBox);
  imgTh.cornerRadius = 2;
  legend.addSpacer(CFG.legendGap);
  const lTh = legend.addText("Kate");
  lTh.font = Font.systemFont(CFG.legendFontSize);
  lTh.textColor = CFG.label;

  w.addSpacer(CFG.chartTopExtra);

  const chartW = 600, chartH = CFG.chartHeight;
  const img = drawStackedLines(new Size(chartW, chartH), series.me, series.them, yMax);
  const chartStack = w.addStack();
  const chartEl = chartStack.addImage(img);
  chartEl.resizable = true; chartEl.cornerRadius = 8; chartEl.centerAlignImage();

  w.addSpacer(CFG.chartBottomExtra);

  const mondays = [];
  for (const d of series.dates) if (d.getDay() === 1) mondays.push(ddMM(d));
  if (mondays.length === 0) mondays.push(ddMM(series.start), ddMM(series.end));

  const xrow = w.addStack(); xrow.layoutHorizontally();
  xrow.addSpacer();
  const lbl = xrow.addText(mondays.join("   Â·   "));
  lbl.font = Font.systemFont(CFG.tickSize);
  lbl.textColor = CFG.label;
  xrow.addSpacer();

  w.addSpacer(4);

  const frow = w.addStack(); frow.layoutHorizontally();
  frow.addSpacer();
  const foot = frow.addText(`${CFG.updatedPrefix} ${updatedAt}`);
  foot.font = Font.italicSystemFont(CFG.footerSize);
  foot.textColor = CFG.label;
  foot.centerAlignText();
  frow.addSpacer();

  w.refreshAfterDate = new Date(Date.now() + CFG.refreshMinutes*60*1000);
  return w;
}


// â”€â”€ main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function run(){
  try{
    const { fm, root, indexPath, index } = await resolveRootAndIndex();

    let contactId = CFG.contactId;
    if (isPlaceholderContactId(contactId)) {
      const picked = pickContactIdFromIndex(index);
      if (!picked) throw new Error("No usable contacts found in index.json.");
      contactId = picked;
    }

    const { rollupPath, meAvatarPath, themAvatarPath } = await buildPathsForContact({ fm, root, contactId });

    // iCloud prefetch poke
    await prefetchIcloudFiles({ fm, indexPath, rollupPath, meAvatarPath, themAvatarPath });

    const { json, mtime } = await loadRollup(rollupPath, fm, contactId, root);

    const series = buildSeries(json, CFG.lookbackDays, CFG.meKey, CFG.themKey);
    const yMax = yMaxFor(series.total, CFG.headroom);
    const updated = (json && json.updated_at)
      ? json.updated_at.replace("T"," ").slice(0,16)
      : fmtDateTime(mtime);

    const w = buildWidget({ series, updatedAt: updated, yMax });
    Script.setWidget(w);
    if (config.runsInApp) await w.presentMedium();
  } catch (err){
    const w = new ListWidget(); w.backgroundColor = new Color("#222");
    const t = w.addText("Message History"); t.textColor = Color.white(); t.font = Font.semiboldSystemFont(14);
    w.addSpacer(6);
    const e = w.addText(String(err)); e.textColor = Color.red(); e.minimumScaleFactor = 0.6; e.lineLimit = 6;
    Script.setWidget(w);
    if (config.runsInApp) await w.presentMedium();
  }
  Script.complete();
}
await run();