/**
 * iMessage Trend — Daily History (Stacked Area, Unsmoothed)
 * =========================================================
 * Renders the last N days of your iMessage DM activity with a stacked area:
 *   • Lower area/line = You (Ste)
 *   • Upper area/line = Total (Ste + Kate)
 *   • Simple grid, legend, Monday tick labels, and “Updated:” footer
 *
 * 📦 DATA SOURCE
 *   • Generated by the macOS “imexporter” app:
 *     https://github.com/spcurtis81/imexporter
 *   • Reads from per-contact JSON rollups created by the exporter:
 *       iCloud Drive / Documents / Social / Messaging / iMessage /
 *         index.json
 *         _me/
 *           avatar.png
 *         <CONTACT_ID>/
 *           rollup.json   ← this script reads this file
 *           avatar.png
 *     (Example <CONTACT_ID>: +447962786922)
 *
 * 🔧 PREREQUISITES
 *   • Scriptable (iOS)
 *   • Scriptable File Bookmark named “MessagesStats” pointing to:
 *       iCloud Drive / Documents / Social / Messaging / iMessage
 *   • At least one contact exported by the macOS imexporter app
 *
 * 📝 CONFIGURATION
 *   • Set CFG.contactId to the contact folder this widget should chart.
 *   • Adjust lookback days, colors, and headroom if desired.
 *
 * 🔁 REFRESH
 *   • iOS controls widget refresh cadence (typically 15–60 minutes).
 *   • This script hints at CFG.refreshMinutes (default: 30).
 *
 * ——————————————————————————————————————————————
 * © Stephen Curtis, 2025. MIT License (see repo).
 */

// ── CONFIG ──────────────────────────────────────────────────────────────
const CFG = {
  // New structure: bookmark points to “…/Documents/Social/Messaging/iMessage”
  bookmarkName: "MessagesStats",
  // The per-contact folder name (exact id used by the exporter)
  contactId: "<<PHONE_NUMBER>>",   // e.g. "+447962786922"

  // Keys inside rollup.json -> days[YYYY-MM-DD]
  meKey: "me",
  themKey: "them",

  // Window & scaling
  lookbackDays: 30,    // number of days to show (right-aligned, includes today)
  headroom: 0.10,      // extra headroom above observed max so lines don't touch top

  // Look & feel (colors & text) — unchanged
  bgGradient: { colors: ["#2f8f7f", "#0f6a5d"], locations: [0, 1], angle: 135 },
  meFill:   new Color("#ffffff", 0.25),  // area for Ste (under white Ste line)
  themFill: new Color("#ffffff", 0.40),  // area between Ste and Total (Kate)
  meLine:   new Color("#ffffff", 0.95),  // Ste line
  totLine:  new Color("#ffffff", 1.00),  // Total line
  grid:     new Color("#ffffff", 0.18),  // horizontal grid lines
  label:    new Color("#ffffff", 0.92),  // axis/legend/footer text
  titleCol: new Color("#ffffff", 0.96),  // title text

  title: "Message History",
  updatedPrefix: "Updated:",

  // Layout (Medium)
  padTop: 12, padLeft: 16, padRight: 16, padBottom: 12,
  titleSize: 14,
  tickSize: 10,
  footerSize: 10,

  // Legend
  legendFontSize: 10,
  legendBox: 10,          // swatch size
  legendGap: 6,           // swatch → label
  legendItemGap: 12,      // gap between items

  // Chart sizing
  chartHeight: 120,
  chartTopExtra: 6,
  chartBottomExtra: 8,
  yTicks: 3,

  // Line thickness
  meLineWidth: 2.0,
  totLineWidth: 2.0,

  // Super-sample to reduce jaggies, then downscale
  supersample: 2,

  // Widget auto-refresh hint
  refreshMinutes: 30,
};


// ── util helpers ────────────────────────────────────────────────────────
function fontWith(size, weight){
  switch((weight||"").toLowerCase()){
    case "heavy": return Font.heavySystemFont(size);
    case "bold": return Font.boldSystemFont(size);
    case "semibold": return Font.semiboldSystemFont(size);
    default: return Font.systemFont(size);
  }
}
function keyFor(d){ return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,"0")}-${String(d.getDate()).padStart(2,"0")}`; }
function addDays(date, n){ const d=new Date(date); d.setDate(d.getDate()+n); return d; }
function fmtDateTime(dt){
  const y=dt.getFullYear(), m=String(dt.getMonth()+1).padStart(2,"0"), d=String(dt.getDate()).padStart(2,"0");
  const H=String(dt.getHours()).padStart(2,"0"), M=String(dt.getMinutes()).padStart(2,"0");
  return `${y}-${m}-${d} ${H}:${M}`;
}
function ddMM(d){ const dd=String(d.getDate()).padStart(2,"0"); const mm=String(d.getMonth()+1).padStart(2,"0"); return `${dd}/${mm}`; }


// ── data load/prep (NEW: resolve paths via MessagesStats + contactId) ──
async function resolveRollupPath(){
  const fm = FileManager.iCloud();
  if (!fm.bookmarkExists(CFG.bookmarkName)){
    throw new Error(`Bookmark "${CFG.bookmarkName}" not found. (Scriptable → Settings → File Bookmarks)`);
  }
  const root = fm.bookmarkedPath(CFG.bookmarkName); // …/Documents/Social/Messaging/iMessage
  const contactDir = fm.joinPath(root, CFG.contactId);
  const rollupPath = fm.joinPath(contactDir, "rollup.json");
  return { fm, rollupPath };
}

async function loadRollup(rollupPath, fm){
  await fm.downloadFileFromiCloud(rollupPath);
  if (!fm.fileExists(rollupPath)) throw new Error("Rollup file not found.");
  const raw = fm.readString(rollupPath); if (!raw) throw new Error("Rollup file empty.");
  return { json: JSON.parse(raw), mtime: fm.modificationDate(rollupPath) };
}

function buildSeries(data, days, meKey, themKey){
  const map = (data && data.days) || {};
  const end = new Date();
  const start = addDays(end, -(days-1));
  const dates=[], me=[], them=[], total=[];
  for (let i=0;i<days;i++){
    const d = addDays(start, i);
    const rec = map[keyFor(d)] || {};
    const m = Number.isFinite(rec[meKey]) ? rec[meKey] : 0;
    const t = Number.isFinite(rec[themKey]) ? rec[themKey] : 0;
    dates.push(d); me.push(m); them.push(t); total.push(m+t);
  }
  return { dates, me, them, total, start, end };
}

function yMaxFor(total, headroom){ const mx = Math.max(1, ...total); return mx * (1 + headroom); }


// ── chart: straight lines + stacked fills (UNCHANGED) ──────────────────
function drawStackedLines(size, meArr, themArr, yMax){
  const SS = Math.max(1, CFG.supersample|0);
  const Hi = new Size(size.width*SS, size.height*SS);

  const ctx = new DrawContext();
  ctx.size = Hi; ctx.opaque = false; ctx.respectScreenScale = true;

  const W = Hi.width, H = Hi.height;
  const n = meArr.length;
  const stepX = n>1 ? (W-1)/(n-1) : 0;
  const pxPerY = H / yMax;

  const ptsMe = [], ptsTot = [];
  for (let i=0;i<n;i++){
    const x = i*stepX;
    const yMe  = H - (meArr[i]             * pxPerY);
    const yTot = H - ((meArr[i]+themArr[i]) * pxPerY);
    ptsMe.push({x, y: Math.max(0, Math.min(H, yMe ))});
    ptsTot.push({x, y: Math.max(0, Math.min(H, yTot))});
  }

  // grid
  ctx.setStrokeColor(CFG.grid); ctx.setLineWidth(SS*1);
  for (let g=0; g<CFG.yTicks; g++){
    const frac = g/(CFG.yTicks-1), y = H - frac*H;
    const p = new Path(); p.move(new Point(0,y)); p.addLine(new Point(W,y));
    ctx.addPath(p); ctx.strokePath();
  }

  // area: me
  {
    const p = new Path();
    p.move(new Point(ptsMe[0].x, H));
    for (let i=0;i<ptsMe.length;i++) p.addLine(new Point(ptsMe[i].x, ptsMe[i].y));
    p.addLine(new Point(ptsMe[ptsMe.length-1].x, H));
    p.closeSubpath();
    ctx.setFillColor(CFG.meFill); ctx.addPath(p); ctx.fillPath();

    const pl = new Path();
    pl.move(new Point(ptsMe[0].x, ptsMe[0].y));
    for (let i=1;i<ptsMe.length;i++) pl.addLine(new Point(ptsMe[i].x, ptsMe[i].y));
    ctx.setStrokeColor(CFG.meLine); ctx.setLineWidth(CFG.meLineWidth*SS);
    ctx.addPath(pl); ctx.strokePath();
  }

  // area: them (between me and total)
  {
    const p = new Path();
    p.move(new Point(ptsTot[0].x, ptsTot[0].y));
    for (let i=1;i<ptsTot.length;i++) p.addLine(new Point(ptsTot[i].x, ptsTot[i].y));
    for (let i=ptsMe.length-1;i>=0;i--) p.addLine(new Point(ptsMe[i].x, ptsMe[i].y));
    p.closeSubpath();
    ctx.setFillColor(CFG.themFill); ctx.addPath(p); ctx.fillPath();

    const pl = new Path();
    pl.move(new Point(ptsTot[0].x, ptsTot[0].y));
    for (let i=1;i<ptsTot.length;i++) pl.addLine(new Point(ptsTot[i].x, ptsTot[i].y));
    ctx.setStrokeColor(CFG.totLine); ctx.setLineWidth(CFG.totLineWidth*SS);
    ctx.addPath(pl); ctx.strokePath();
  }

  // downscale for AA
  const hi = ctx.getImage();
  const ctx2 = new DrawContext();
  ctx2.size = size; ctx2.opaque = false; ctx2.respectScreenScale = true;
  ctx2.drawImageInRect(hi, new Rect(0,0,size.width,size.height));
  return ctx2.getImage();
}

// Small colored square image for legend
function swatchImage(color, size){
  const ctx = new DrawContext();
  ctx.size = new Size(size, size);
  ctx.opaque = false; ctx.respectScreenScale = true;
  ctx.setFillColor(color);
  ctx.fillRect(new Rect(0,0,size,size));
  // subtle white border for visibility on dark gradients
  ctx.setStrokeColor(new Color("#ffffff", 0.8));
  ctx.setLineWidth(1);
  ctx.strokeRect(new Rect(0.5,0.5,size-1,size-1));
  return ctx.getImage();
}


// ── widget assembly (UNCHANGED) ─────────────────────────────────────────
function buildWidget({series, updatedAt, yMax}){
  const w = new ListWidget();
  w.setPadding(CFG.padTop, CFG.padLeft, CFG.padBottom, CFG.padRight);

  const grad = new LinearGradient();
  grad.colors = CFG.bgGradient.colors.map(c => new Color(c));
  grad.locations = CFG.bgGradient.locations;
  grad.angle = CFG.bgGradient.angle;
  w.backgroundGradient = grad;

  // Title + legend row
  const trow = w.addStack(); trow.layoutHorizontally();
  const icon = trow.addImage(SFSymbol.named("chart.xyaxis.line").image);
  icon.imageSize = new Size(16,16); icon.tintColor = CFG.titleCol;
  trow.addSpacer(8);
  const tt = trow.addText(CFG.title);
  tt.font = fontWith(CFG.titleSize, "semibold");
  tt.textColor = CFG.titleCol;

  trow.addSpacer(); // push legend to the far right

  const legend = trow.addStack();
  legend.layoutHorizontally(); legend.centerAlignContent();
  // item: Ste
  const imgMe = legend.addImage(swatchImage(CFG.meFill, CFG.legendBox));
  imgMe.imageSize = new Size(CFG.legendBox, CFG.legendBox);
  imgMe.cornerRadius = 2;
  legend.addSpacer(CFG.legendGap);
  const lMe = legend.addText("Ste");
  lMe.font = Font.systemFont(CFG.legendFontSize);
  lMe.textColor = CFG.label;

  legend.addSpacer(CFG.legendItemGap);

  // item: Kate
  const imgTh = legend.addImage(swatchImage(CFG.themFill, CFG.legendBox));
  imgTh.imageSize = new Size(CFG.legendBox, CFG.legendBox);
  imgTh.cornerRadius = 2;
  legend.addSpacer(CFG.legendGap);
  const lTh = legend.addText("Kate");
  lTh.font = Font.systemFont(CFG.legendFontSize);
  lTh.textColor = CFG.label;

  w.addSpacer(CFG.chartTopExtra);

  // Chart image
  const chartW = 600, chartH = CFG.chartHeight;
  const img = drawStackedLines(new Size(chartW, chartH), series.me, series.them, yMax);
  const chartStack = w.addStack();
  const chartEl = chartStack.addImage(img);
  chartEl.resizable = true; chartEl.cornerRadius = 8; chartEl.centerAlignImage();

  w.addSpacer(CFG.chartBottomExtra);

  // X labels: each Monday in window
  const mondays = [];
  for (const d of series.dates) if (d.getDay() === 1) mondays.push(ddMM(d));
  if (mondays.length === 0) mondays.push(ddMM(series.start), ddMM(series.end));

  const xrow = w.addStack(); xrow.layoutHorizontally();
  xrow.addSpacer();
  const lbl = xrow.addText(mondays.join("   ·   "));
  lbl.font = Font.systemFont(CFG.tickSize);
  lbl.textColor = CFG.label;
  xrow.addSpacer();

  w.addSpacer(4);

  // Footer centered
  const frow = w.addStack(); frow.layoutHorizontally();
  frow.addSpacer();
  const foot = frow.addText(`${CFG.updatedPrefix} ${updatedAt}`);
  foot.font = Font.italicSystemFont(CFG.footerSize);
  foot.textColor = CFG.label;
  foot.centerAlignText();
  frow.addSpacer();

  w.refreshAfterDate = new Date(Date.now() + CFG.refreshMinutes*60*1000);
  return w;
}


// ── main ────────────────────────────────────────────────────────────────
async function run(){
  try{
    const { fm, rollupPath } = await resolveRollupPath();
    const { json, mtime } = await loadRollup(rollupPath, fm);

    const series = buildSeries(json, CFG.lookbackDays, CFG.meKey, CFG.themKey);
    const yMax = yMaxFor(series.total, CFG.headroom);
    const updated = (json && json.updated_at)
      ? json.updated_at.replace("T"," ").slice(0,16)
      : fmtDateTime(mtime);

    const w = buildWidget({ series, updatedAt: updated, yMax });
    Script.setWidget(w);
    if (config.runsInApp) await w.presentMedium();
  } catch (err){
    const w = new ListWidget(); w.backgroundColor = new Color("#222");
    const t = w.addText("Message History"); t.textColor = Color.white(); t.font = Font.semiboldSystemFont(14);
    w.addSpacer(6);
    const e = w.addText(String(err)); e.textColor = Color.red(); e.minimumScaleFactor = 0.5;
    Script.setWidget(w);
    if (config.runsInApp) await w.presentMedium();
  }
  Script.complete();
}
await run();
