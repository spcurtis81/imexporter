/**
 * iMessage Stats (Medium) — Lifetime Totals, Daily Avg, Record Day
 * ================================================================
 * What it shows
 *  • Left column: "Daily Avg" and all-time "Record" (with record date)
 *  • Right column: lifetime totals for Ste, Kate, and Total
 *
 * Data source
 *  • Generated by the macOS exporter: https://github.com/spcurtis81/imexporter
 *  • File layout (per-contact):
 *      iCloud Drive / Documents / Social / Messaging / iMessage /
 *        index.json
 *        _me/
 *          avatar.png
 *        <CONTACT_ID>/
 *          rollup.json   ← this widget reads this file
 *          avatar.png
 *
 * Prerequisites
 *  • Scriptable (iOS)
 *  • Scriptable File Bookmark named "MessagesStats" that points to:
 *      iCloud Drive / Documents / Social / Messaging / iMessage
 *
 * Notes
 *  • No layout/style changes vs your working version.
 *  • Only data-loading is hardened (auto-contact + safe iCloud prefetch + better errors).
 *
 * © Stephen Curtis, 2025 — MIT (see repo)
 */

// ╔══════════════════════════════════════════════════════════════════════╗
// ║  CONFIGURATION                                                       ║
// ╚══════════════════════════════════════════════════════════════════════╝
const CFG = {
  bookmarkName: "MessagesStats", // File Bookmark → .../Documents/Social/Messaging/iMessage

  // If blank/placeholder, auto-select first enabled contact from index.json
  contactId: "",                 // e.g. "+447962786922" (folder name under bookmark)

  meKey: "me",
  themKey: "them",

  title: "iMessage Stats",
  bgGradient: { colors: ["#6F76E4", "#3E3A9E"], locations: [0, 1], angle: 135 },

  titleColor: new Color("#FFFFFF", 0.96),
  textColor:  new Color("#FFFFFF", 0.92),
  subColor:   new Color("#FFFFFF", 0.80),
  divider:    new Color("#FFFFFF", 0.28),

  padTop: 14, padLeft: 18, padRight: 18, padBottom: 12,

  titleSize: 16,

  leftHeaderSize: 12,
  leftBigSize: 38,
  recordHeaderSize: 11,
  recordValueSize: 22,

  rightHeaderSize: 12,
  rightLabelSize: 14,
  rightValueSize: 20,

  rowGap: 6,

  columnMode: "percent",
  leftPercent: 0.50,
  leftFixedWidthPx: null,
  gutterPx: 10,

  showUpdated: true,
  updatedPrefix: "Updated:",
  footerSize: 11,

  refreshMinutes: 30,
};

// ╔══════════════════════════════════════════════════════════════════════╗
/*  UTILITY HELPERS                                                      */
// ╚══════════════════════════════════════════════════════════════════════╝
function fontWith(size, weight){
  switch((weight||"").toLowerCase()){
    case "heavy":     return Font.heavySystemFont(size);
    case "bold":      return Font.boldSystemFont(size);
    case "semibold":  return Font.semiboldSystemFont(size);
    default:          return Font.systemFont(size);
  }
}
function fmtInt(n){ return Number(n||0).toLocaleString(); }

function isPlaceholderContactId(id){
  if(!id) return true;
  const s = String(id).trim();
  return s === "" || s.includes("PHONE_NUMBER") || s.includes("<<") || s.includes(">>");
}

// ── iCloud root + index + contact resolution ───────────────────────────
async function resolveRootAndIndex(){
  const fm = FileManager.iCloud();
  if (!fm.bookmarkExists(CFG.bookmarkName)){
    throw new Error(`Bookmark "${CFG.bookmarkName}" not found. (Scriptable → Settings → File Bookmarks)`);
  }
  const root = fm.bookmarkedPath(CFG.bookmarkName);
  const indexPath = fm.joinPath(root, "index.json");

  if(!fm.fileExists(indexPath)){
    throw new Error(`index.json not found in bookmarked folder.\nBookmark points to:\n${root}`);
  }

  await fm.downloadFileFromiCloud(indexPath);
  const raw = fm.readString(indexPath);
  let index;
  try { index = JSON.parse(raw); }
  catch { throw new Error("index.json exists but is not valid JSON."); }

  return { fm, root, indexPath, index };
}

function pickContactIdFromIndex(index){
  const contacts = Array.isArray(index?.contacts) ? index.contacts : [];
  const enabled = contacts.filter(c => c && (c.enabled === undefined || c.enabled === true));

  // New schema: { number, label, enabled }
  const c1 = enabled.find(c => c.number);
  if (c1?.number) return c1.number;

  // Old schema: { id, path, displayName, ... }
  const c2 = enabled.find(c => c.id);
  if (c2?.id) return c2.id;

  return null;
}

function listLikelyContactFolders(fm, root){
  try {
    const items = fm.listContents(root) || [];
    return items.filter(n => n && n.startsWith("+")).slice(0, 20);
  } catch {
    return [];
  }
}

async function buildPathsForContact({ fm, root, contactId }){
  const contactDir = fm.joinPath(root, contactId);
  const rollupPath = fm.joinPath(contactDir, "rollup.json");
  return { contactDir, rollupPath };
}

async function safeDownload(fm, path){
  if(!fm.fileExists(path)) return false;
  await fm.downloadFileFromiCloud(path);
  return true;
}

async function prefetchIcloudFiles({ fm, indexPath, rollupPath }){
  await safeDownload(fm, indexPath);
  await safeDownload(fm, rollupPath);
}

async function loadRollup(rollupPath, fm, contactId, root){
  if (!fm.fileExists(rollupPath)){
    const options = listLikelyContactFolders(fm, root);
    const hint = options.length ? `\n\nContact folders I can see:\n- ${options.join("\n- ")}` : "";
    throw new Error(
      `rollup.json not found for contact "${contactId}".\nExpected:\n${rollupPath}\n\nCheck CFG.contactId or ensure exporter has created rollup.json.${hint}`
    );
  }
  await fm.downloadFileFromiCloud(rollupPath);
  const raw = fm.readString(rollupPath);
  if (!raw) throw new Error("Rollup file is empty.");
  return { json: JSON.parse(raw), mtime: fm.modificationDate(rollupPath) };
}

// ── stats computation (unchanged) ──────────────────────────────────────
function computeStats(json, meKey, themKey){
  const days = (json && json.days) || {};
  const entries = Object.entries(days);
  if (entries.length === 0) {
    return { dailyAvg:0, recordCount:0, recordDate:"—", sumMe:0, sumThem:0, sumTotal:0, updatedAt:"—" };
  }

  let sumMe = 0, sumThem = 0, sumTotal = 0;
  let recordCount = -1, recordDate = "";
  for (const [date, v] of entries){
    const m = Number(v[meKey]  ?? 0);
    const t = Number(v[themKey]?? 0);
    const tot = m + t;
    sumMe += m; sumThem += t; sumTotal += tot;
    if (tot > recordCount){ recordCount = tot; recordDate = date; }
  }

  const dailyAvg = Math.round(sumTotal / entries.length);
  return {
    dailyAvg,
    recordCount,
    recordDate,
    sumMe,
    sumThem,
    sumTotal,
    updatedAt: (json && json.updated_at)
      ? json.updated_at.replace("T"," ").slice(0,16)
      : "—",
  };
}

function drawDividerImage(size, color){
  const ctx = new DrawContext();
  ctx.size = size; ctx.opaque = false; ctx.respectScreenScale = true;
  ctx.setFillColor(color);
  ctx.fillRect(new Rect(0,0,size.width,size.height));
  return ctx.getImage();
}

function estimateWidgetInnerWidth(){
  const screenPts = Device.screenSize().width / Device.screenScale();
  return Math.max(280, Math.min(screenPts - (CFG.padLeft + CFG.padRight), 640));
}

function computeColumnWidths() {
  const totalW = estimateWidgetInnerWidth();
  const gutter = Math.max(0, CFG.gutterPx);

  let leftW;
  if (CFG.columnMode === "fixed" && CFG.leftFixedWidthPx != null) {
    leftW = Math.min(Math.max(120, CFG.leftFixedWidthPx), totalW - gutter - 120);
  } else {
    const pct = Math.min(0.9, Math.max(0.1, CFG.leftPercent || 0.5));
    leftW = Math.floor((totalW - gutter) * pct);
  }
  const rightW = Math.max(120, totalW - gutter - leftW);
  return { leftW, rightW, gutter };
}

// ╔══════════════════════════════════════════════════════════════════════╗
/*  WIDGET LAYOUT (unchanged visuals)                                    */
// ╚══════════════════════════════════════════════════════════════════════╝
function buildWidget(stats){
  const w = new ListWidget();
  w.setPadding(CFG.padTop, CFG.padLeft, CFG.padBottom, CFG.padRight);

  const grad = new LinearGradient();
  grad.colors = CFG.bgGradient.colors.map(c => new Color(c));
  grad.locations = CFG.bgGradient.locations;
  grad.angle = CFG.bgGradient.angle;
  w.backgroundGradient = grad;

  const titleRow = w.addStack(); titleRow.layoutHorizontally();
  const icon = titleRow.addImage(SFSymbol.named("tablecells").image);
  icon.imageSize = new Size(16,16); icon.tintColor = CFG.titleColor;
  titleRow.addSpacer(8);
  const ttl = titleRow.addText(CFG.title);
  ttl.font = fontWith(CFG.titleSize, "semibold");
  ttl.textColor = CFG.titleColor;

  w.addSpacer(6);

  const { leftW, rightW, gutter } = computeColumnWidths();
  const cols = w.addStack(); cols.layoutHorizontally();

  // LEFT
  const left = cols.addStack(); left.layoutVertically(); left.size = new Size(leftW, 0);

  const leftHdr = left.addText("Daily Avg");
  leftHdr.font = fontWith(CFG.leftHeaderSize, "semibold");
  leftHdr.textColor = CFG.subColor;
  left.addSpacer(2);

  const avgTxt = left.addText(fmtInt(stats.dailyAvg));
  avgTxt.font = fontWith(CFG.leftBigSize, "heavy");
  avgTxt.textColor = CFG.textColor;
  avgTxt.lineLimit = 1; avgTxt.minimumScaleFactor = 0.8;

  left.addSpacer(6);

  const recHdr = left.addText("Record");
  recHdr.font = fontWith(CFG.recordHeaderSize, "semibold");
  recHdr.textColor = CFG.subColor;
  left.addSpacer(1);

  const recVal = left.addText(fmtInt(stats.recordCount));
  recVal.font = fontWith(CFG.recordValueSize, "bold");
  recVal.textColor = CFG.textColor;
  recVal.lineLimit = 1; recVal.minimumScaleFactor = 0.8;

  const recDate = left.addText(`(${stats.recordDate})`);
  recDate.font = Font.italicSystemFont(CFG.footerSize);
  recDate.textColor = CFG.subColor;
  recDate.lineLimit = 1; recDate.minimumScaleFactor = 0.8;

  cols.addSpacer(gutter);

  // RIGHT
  const right = cols.addStack(); right.layoutVertically(); right.size = new Size(rightW, 0);

  const rightHdr = right.addText("All Time");
  rightHdr.font = fontWith(CFG.rightHeaderSize, "semibold");
  rightHdr.textColor = CFG.subColor;
  right.addSpacer(4);

  function row(label, value, bold=false){
    const r = right.addStack(); r.layoutHorizontally();

    const l = r.addText(label);
    l.font = bold ? fontWith(CFG.rightLabelSize, "semibold")
                  : Font.systemFont(CFG.rightLabelSize);
    l.textColor = CFG.textColor;
    l.lineLimit = 1; l.minimumScaleFactor = 0.7;

    r.addSpacer();

    const v = r.addText(fmtInt(value));
    v.font = fontWith(CFG.rightValueSize, bold ? "bold" : "semibold");
    v.textColor = CFG.textColor;
    v.rightAlignText(); v.lineLimit = 1; v.minimumScaleFactor = 0.7;

    right.addSpacer(CFG.rowGap);
  }

  row("Ste",  stats.sumMe,   false);
  row("Kate", stats.sumThem, false);

  const div = right.addStack(); div.layoutHorizontally();
  const hair = div.addImage(drawDividerImage(new Size(rightW, 1), CFG.divider));
  hair.resizable = true; hair.centerAlignImage();
  right.addSpacer(CFG.rowGap);

  row("Total", stats.sumTotal, true);

  right.addSpacer();

  if (CFG.showUpdated){
    const footRow = right.addStack(); footRow.layoutHorizontally();
    footRow.addSpacer();
    const foot = footRow.addText(`${CFG.updatedPrefix} ${stats.updatedAt}`);
    foot.font = Font.italicSystemFont(CFG.footerSize);
    foot.textColor = CFG.subColor;
    foot.lineLimit = 1; foot.minimumScaleFactor = 0.75;
  }

  w.refreshAfterDate = new Date(Date.now() + CFG.refreshMinutes*60*1000);
  return w;
}

// ╔══════════════════════════════════════════════════════════════════════╗
/*  MAIN                                                                 */
// ╚══════════════════════════════════════════════════════════════════════╝
async function run(){
  try{
    const { fm, root, indexPath, index } = await resolveRootAndIndex();

    let contactId = CFG.contactId;
    if (isPlaceholderContactId(contactId)) {
      const picked = pickContactIdFromIndex(index);
      if (!picked) throw new Error("No usable contacts found in index.json.");
      contactId = picked;
    }

    const { rollupPath } = await buildPathsForContact({ fm, root, contactId });

    // iCloud prefetch poke (safe)
    await prefetchIcloudFiles({ fm, indexPath, rollupPath });

    const { json } = await loadRollup(rollupPath, fm, contactId, root);

    const stats = computeStats(json, CFG.meKey, CFG.themKey);
    const w = buildWidget(stats);
    Script.setWidget(w);
    if (config.runsInApp) await w.presentMedium();
  } catch (err){
    const w = new ListWidget(); w.backgroundColor = new Color("#222");
    const t = w.addText(CFG.title || "iMessage Stats");
    t.textColor = Color.white(); t.font = Font.semiboldSystemFont(14);
    w.addSpacer(6);
    const e = w.addText(String(err));
    e.textColor = Color.red(); e.minimumScaleFactor = 0.6; e.lineLimit = 6;
    Script.setWidget(w);
    if (config.runsInApp) await w.presentMedium();
  }
  Script.complete();
}
await run();